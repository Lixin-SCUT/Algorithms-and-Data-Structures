> 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
> 
> 示例:
> 输入: 38
> 输出: 2 
> 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
> 进阶:
> 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？
> 
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/add-digits
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
> 

难点：如何在常数时间复杂度完成
思路：最后还是只想出了暴力法，其实就是判断当前值是否为个位数，如果不是的话就进入循环，循环内依次把10的余数和放到临时变量内，再把临时变量赋给当前值。
```
class Solution {
public:
    int addDigits(int num) {
        while(num>=10){
            int temp=0;
            while(num>0){
                temp+=num%10;
                num=num/10;
            }
            num=temp;
        }
        return num;
    }
};
```
提前预知到常数时间肯定是用了数学思路的了，下面是网友题解
1.
> O(1) 数学推理：设某个数字的字符串表示为'abc'，则这个数字代表a*100 + b*10 + c，转换后成为a + b + c，可见每次转换相当于把原数字减去a*99 + b*9 = 9 * (a*11 + b)，可以推出只要高于个位的位置上有数字，算法就会减去一个小于原数字的9的倍数，这就相当于数字 % 9。但9 % 9 = 0，而 9 本身就没有十位，因此需要考虑原数字是 0 或 9 的倍数的特殊情况
> 首先计算num % 9，若结果为 0 则考虑num本身是否为 0，若不为 0 返回 9
2.
> 假设一个三位数整数n=100*a+10*b+c,变化后addn=a+b+c；
> 两者的差值n-addn=99a+9b，差值可以被9整除，说明每次缩小9的倍数
> 那么我们可以对res=num%9，若不为0则返回res，为0则返回9

> class Solution {
> public:
>     int addDigits(int num) {
>         if(num>9)
>         {
>             num=num%9;
>             if(num==0)
>                 return 9;
>         }
>         return num;
>     }
> };

嗯...我是来码代码的别人是来学数学的hhh
