题目描述
> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

【未做出】
第一个想法是模仿计算机底层的相加操作，亦即异或和进位。
但是在进位的时候遇到困难了
其实求进位本身不难，就是如何和普通的单位相加融合
最终我的想法和书本的一致，不可能在一次循环内完成异或和进位的，必须分开计算，一次一次地计算；
这样子就比较简单了，将异或和进位分开保存，然后再不断循环得到两个结果的异或和进位，直到没有进位
记得进位一定要左移

```
class Solution {
public:
    int Add(int num1, int num2)
    {
        int flag;
        int temp;
        //int bit;
        //res = 0;
        //bit = 1;
        while(num2)
        {
            temp = num1 ^ num2;
            flag = num1 & num2;
            num1 = temp;
            num2 = flag << 1; // 不要忘了移位
        }
        return num1;
    }
};
```

书本题解：
> 把二进制的加法用位运算来替代。第一步不考虑进位对每一位相 加。0 加 0、1 加 1 的结果都是 0，0 加 1、1 加 0 的结果都是 1。 我们注意到，这和异或的结果是一样的。对异或而言，0 和 0、1和 1 的异或结果是 0,而 0 和 1、1 和 0 的异或 结果是 1。接着考虑第二步进位，对 0 加 0、0 加 1、1 加 0 而言，都不会产生进位，只 有 1 加 1 时，会向前产生一个进位。此时我们可以想象成两个数先做位与运算，然后再向左移动一位。 只有两个数都是 1 的时候，位与得到的结果是 1，其余都是 0。第三步把前两个步骤的结果相加。第三步相加的过程依然是重复前面两步，直到不产生进位为止。
```
int Add(int num1, int num2)
{
    int sum, carry;
    do
    {
        sum = num1 ^ num2;
        carry = (num1 & num2) << 1;

        num1 = sum;
        num2 = carry;
    }
    while(num2 != 0);

    return num1;
}
```
