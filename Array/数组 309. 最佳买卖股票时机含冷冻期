官方原题：
> 
> 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
> 示例:
> 输入: [1,2,3,0,2]
> 输出: 3 
> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
> 
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
> 

这一题主要的考点在于这个冷冻期，冷冻期明显地影响了我们的状态转移，一开始我被这个东西弄得到是抓耳挠腮，一直在思考怎么在源码上改动。但是后来才发现这个其实是一个非常不好的习惯，就是没有跳出代码的约束，总想着从代码出来修修补补，其实应该从根源上的抽象出发思考问题所在，才能解决具体的代码问题。
后来冷静下来，利用题解中学到的只是，将所有的状态列出来
0-0-0 0-1-0 0-1-1 1-0-0 1-0-1 1-1-0 1-1-1
二进制来看三位数就八个状态，其中收到冷冻期的影响，1-0-1是不存在的，所以第三天的1买入状态是受到第一天的影响，其他情况下均不受影响，代码无须改变，所以代码的改动主要集中于
`dp[i][k][1] = dp[i - 1][k][1]>dp[i - 1][k - 1][0] - prices[i] ? dp[i - 1][k][1] : dp[i - 1][k - 1][0] - prices[i];`
上面
同时由于k不受限制，k是完全可以去掉的
最后的想法是
```
	dp0= dp0>dp1+prices[i]?dp0:dp1+prices[i];	    
  dp1= dp1>dpt-prices[i]?dp1:dpt-prices[i];
```
dpt代表了前两天的交易dp0；
但是保存这个dp0比较麻烦，需要额外的两个向量
```
dpt2=dp0;
dp0= dp0>dp1+prices[i]?dp0:dp1+prices[i];	    
 dp1= dp1>dpt-prices[i]?dp1:dpt-prices[i];
dpt=dpt2;
```
首先保存当前的dp0（昨天的）准备给明天用，然后使用前天的dp0也就是dpt进行计算，最后将昨天的dp0 也就是dpt2赋给dpt
最后代码：
```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        const int n = prices.size();
        if(n==0||n==1)
            return 0;
       int dp0=0,dpt= 0 ;
	   int dp1 = - prices[0];
       int dpt2;
	for (int i = 1; i < n; ++i) {
            dpt2=dp0;
			dp0= dp0>dp1+prices[i]?dp0:dp1+prices[i];	    
            dp1= dp1>dpt-prices[i]?dp1:dpt-prices[i];
            dpt=dpt2;
			}
		
	
	return dp0;
    }
};
```

其实中间几次提交都闹出了不少低级错误，一开始dpt dpt2忘了初始化，直接未定义值出来结果三万多还不信重新提交了一次。。。恍然大悟之后将dpt进行赋值的时候又鸠占鹊巢吧dp0的初始值给占去了，最后远程连接实验室电脑用vs15检查才发现了问题所在，还是得细心啊！
