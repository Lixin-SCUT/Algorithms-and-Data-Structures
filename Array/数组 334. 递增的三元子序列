> 给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。
> 数学表达式如下:
> 如果存在这样的 i, j, k,  且满足 0 ≤ i < j < k ≤ n-1，
> 使得 arr[i] < arr[j] < arr[k] ，返回 true ; 否则返回 false 。
> 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。
> 
> 示例 1:
> 输入: [1,2,3,4,5]
> 输出: true
> 示例 2:
> 输入: [5,4,3,2,1]
> 输出: false
> 
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这道题其实蛮尴尬的，一开始我以为是判断三个连续的递增子序列，楞了一下怎么这么简单，然后提交错误后分析了错误用例才发现其实要求是ijk这三者是符合大小就行了，也就等于说我们希望在整个数组中从左到右找到三个递增的数列就ok了
由于时间不够，所以直接看了题解，一开始判断三个连续的我就不贴出来啦hhh
然后这一次是没有官方题解的，只有网友解：
> 3个连续递增子序列
> 有3个槽位，a,b,c
> 满足条件 a < b < c，即可
> 需要将合适的元素填入这3个槽位
> 
```
class Solution {
    public boolean increasingTriplet(int[] nums) {
        int one = Integer.MAX_VALUE;
        int two = Integer.MAX_VALUE;
        
        for (int n : nums) {
            if (n <= one) {
                one = n;
            } else if (n <= two) {
                two = n;
            } else {
                return true;
            }
        }
        
        return false;
    }
}
```
这一份最简洁，但是没有解释好原理，特别是one=n这一步其实很让人疑惑，比如数组{2，3，1，5} 此时最后结果为one=1 two=3 ，这里其实是有点让人摸不着头脑的
然后看另外一位网友的解答
> 首先，如果只有一个最小值，然后找不到中间值，那么这个数组必然不包含递增的三个数（因为连递增的两个数都找不到）。
> 
> 然后假设我们找到了两个递增的值，那么如果下一个值小于最小值，我们就应该将最小值的指针定位到这个值上。我们尽可能的使用最小值，防止后面出现了更小的一对递增值，而即使不出现，也不妨碍我们找到解（因为最终是看能否找到大于中间值的值）。
> 如果下一个值大于最小值，且小于中间值，则我们使用该值作为中间值(因为如果最小的中间值都得不到解，那么就是false，这样也保证了覆盖所有的情况)。
> 
> 最后，如果找到了大于中间值的值，则为true.
> 

他的代码有点瑕疵我就不贴上来了。这样一来就很明显了，其实我们是把后面出现的最小值叠在了上面，相当于探寻一个新的递增序列，比如{3，4，1，2，5}，1和2都会叠在3和4上面，构成新的递增序列，但是不用怕，因为只有比原值小的才能叠上去，哪怕1把3覆盖了，所以只要出现5，就一定能正确返回true。
我一开始想过用栈的想法，但是栈的先进先出的特性明显不太适合这个状况，当然这个做法其实是有点取巧的了，就如评论里说，最终的结果无法保证下标的正确性。需要付出额外的代价才能返回正确的坐标。
连续几天没通过了吧，不过还是不要气馁，“无用功”乃成功之母！
