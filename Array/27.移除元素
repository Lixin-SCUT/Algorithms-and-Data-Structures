> 题目要求
> 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。
> 
> 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
> 
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
> 
> 示例 1:
> 
> 给定 nums = [3,2,2,3], val = 3,
> 
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
> 
> 你不需要考虑数组中超出新长度后面的元素。
> 示例 2:
> 
> 给定 nums = [0,1,2,2,3,0,4,2], val = 2,
> 
> 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。
> 
> 注意这五个元素可为任意顺序。
> 
> 你不需要考虑数组中超出新长度后面的元素。
> 说明:
> 
> 为什么返回数值是整数，但输出的答案是数组呢?
> 
> 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
> 
> 你可以想象内部操作如下:
> 
> // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
> int len = removeElement(nums, val);
> 
> // 在函数里修改输入数组对于调用者是可见的。
> // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
> for (int i = 0; i < len; i++) {
>     print(nums[i]);
> }
> 
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/remove-element
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

我第一次给出的答案为下：
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int cut_len = 0 ;
        for(int i = 0;i<nums.size();i++)
            if(nums[i]==val){
                ++cut_len;
                for (int j=i;j<nums.size()-2;j++)
                    nums[j]=nums[j+1];
            }
         
         return nums.size()-cut_len;
    }
   
};
```
一提交，可以说是惨不忍睹了，算法有一个特点：解决办法和使用范围是同等重要的！
我这个解法很明显没有考虑连续的val的情况 比如{3，2，2，3}去除2，第二个2很明显被前移略过了，想了一下应该是受算法书的“后面的元素往前移动”的惯性思维的影响，问题是算法书是去掉固定位置的值呢。。。
修改了几次，还是有不少问题
比如一开始j<nums.size()-2处如果size为1，那么无符号的负数直接变成一个怪物，直接内存爆炸。
最后深感这种方法的缺陷，于是观看官方答案：
> 方法一：双指针
> 思路
> 
> 既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 i 和j，其中 i 是慢指针，j 是快指针。
> 
> 算法
> 
> 当 nums[j] 与给定的值相等时，递增 jj 以跳过该元素。只要 nums[j] 不等于nums[j] 我们就复制 nums[j] 到 nums[i]并同时递增两个索引。重复这一过程，直到 jj到达数组的末尾，该数组的新长度为 i。
> 
> 该与 删除排序数组中的重复项 的解法十分相似。
> ```
> Java
> public int removeElement(int[] nums, int val) {
>     int i = 0;
>     for (int j = 0; j < nums.length; j++) {
>         if (nums[j] != val) {
>             nums[i] = nums[j];
>             i++;
>         }
>     }
>     return i;
> }
> ```
> 复杂度分析
> 
> 时间复杂度：O(n)，
> 假设数组总共有 n 个元素，i 和 j 至少遍历 2n 步。
> 
> 空间复杂度：O(1)。

不禁感叹：妙啊！！！（第二种官方解法略坑，不考虑原数组顺序，就不贴上来了）
主要思想就是使用两个指针（迭代器）,一个作为新数组的迭代器，一个作为旧数组的迭代器，旧数组有不同的就交给新数组，目标值的就跳过，既实现了原地修改，又避免了处理目标值这种棘手的问题，真的妙啊！
复现如下：
```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int i = 0;
        for(int j= 0;j<nums.size();++j)
            if(nums[j]!=val)
               nums[i++]=nums[j];
         return i;
    
    }
};
```
其实复现中还是遇到了不少问题，一开始非常自大，看一眼就开始复现了，结果错漏百出，所以还是得老老实实分析出官方解法的算法思想，而不是流于代码表面，这样才可以在其他题目中轻轻松松复现出来！
