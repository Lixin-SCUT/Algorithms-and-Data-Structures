> 给定一个正整数，返回它在 Excel 表中相对应的列名称。
> 
> 例如，
> 
>     1 -> A
>     2 -> B
>     3 -> C
>     ...
>     26 -> Z
>     27 -> AA
>     28 -> AB 
>     ...
> 示例 1:
> 
> 输入: 1
> 输出: "A"
> 示例 2:
> 
> 输入: 28
> 输出: "AB"
> 示例 3:
> 
> 输入: 701
> 输出: "ZY"
> 
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/excel-sheet-column-title
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
> 

这道题第一眼看上去很简单（而且本来标注的也是简单题），就是一道10进制转26进制的题，我本来是按照十进制转二进制的方法来写的（不断除以2，余数进行编码），但是写到最后就发现问题了：0跑哪去了？
仔细看的话似乎题目很详细，但是十进制转X进制是0-9转换过去的，而不是1-10，所以这里是缺了一个0，所以我忙活了一个晚上需要对0进行额外的处理
我忙活了一个晚上的原因也在于判断条件，一开始希望在一个循环内解决战斗，但是有一种特殊情况很烦人：商等于1，余数等于0的情况，这种情况需要借位等于Z
所以最后打算先不管了，在结果字符串中保存0，然后再遍历一次进行借位操作
然后发现借位操作也不简单啊...从前往后的话有一种很奇葩的特例是AAAAAA0，借到第一位，从后往前的话就有A0000000这种奇葩情况。最后使用的是从前往后，不断借位直到借到首位（首位肯定不为0）然后对首位进行判断截断字符串再输出
结果如下：
```
class Solution {
public:
string convertToTitle(int n) {
        string res;
        char temp;
        int i;
        do{
            i=n%26;
            n=n/26;
            if(!i)
                temp='0';
            else
                temp='A'+i-1;
            res= temp+res;
        }while(n);
        for(int c=1;c<res.size();++c) {
            int num=0;
            while(res[c-num]=='0'&&c-num>0){
                res[c-num]='Z';
                if(res[c-num-1]=='A')
                    res[c-num-1]='0';
                else
                    res[c-num-1]=res[c-num-1]-1;
                ++num;
            }        
        }   
        if(res[0]=='0')
            res=res.substr(1,res.size()-1);
        return res;
    }
};
```

终于通过了，前前后后大概花了三小时。
然后看看网友题解
> 思路
> 做这道题要先了解一下, 十进制转二进制, 比如 6 转 成二进制多少?
> 
>  2 |_ 6 _                       ^
>     2|_ 3 _  ······ 0    |
>      2|_ 1 _ ·······1    |
>        |_ 0_ ·······1    |
>  	
> 所以， 我们能得到二进制为 110, 这道题换句话说是十进制转26进制的
> 
> 但是有个难点: 如果 26 转成 字母是多少?
> 
>  26|_ 26 _
>         1   ··· 0
> 这里出现了0, 但是我们26 字母 没有任何一个字母是表示0, 所以我们可以从 商 借一个给余数
> 
>   26| _ 26 _
>   	0 ··· 26
> 这样就可以表示出来了,所以代码如下

```
class Solution:
    def convertToTitle(self, n: int) -> str:
        res = ""
        while n:
            n, y = divmod(n, 26) 
            if y == 0:
                n -= 1
                y = 26
            res = chr(y + 64) + res
        return res
```
> 看了其他做法, 他们先让n 减一
```
class Solution:
    def convertToTitle(self, n: int) -> str:
        res = ""
        while n:
            n -= 1
            n, y = divmod(n, 26) 
            res = chr(y + 65) + res
        return res
```
> 还有一种递归写法:
```
class Solution:
    def convertToTitle(self, n: int) -> str:
        return "" if n == 0 else self.convertToTitle((n - 1) // 26) + chr((n - 1) % 26 + 65
```
C++版
```
class Solution {
public:
    string convertToTitle(int n) {
        char a[26]={'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};//表
        string res;
        while(n)
        {
            n--;//要先减一才能找到对应的字母
            res=a[n%26]+res;
            n=n/26;
        }
        return res;
    }
};
```
> 思路1：此题可以近似看成一个求26进制的题，但是值得注意的是对于26的整数倍，如果我们不加以限制的话就会造成A0的情况出现，而题目给出的条件中是不考虑这种情况的。所以我们只需要排除这种情况对于任何26的整数倍，我们就直接先插入‘Z’，同时还要对原数进行减一的操作。因为如果不进行减一的话对于26所对应的就是AZ（其实就是为了将A0映射为Z要对A0整体减一，由于0-1不够，所以要向A借一位，所以最后就得到了Z。所以我们要插入Z之后再对原数减1。）
> 
> 思路2：上一种思路我们看到了为什么对于26的整数倍要进行减一的操作，同时对于1-25而言，我们应该映射到A-Y，但是对于1我们直接加上A的ascii码就会得到B，所以我们也要进行减一的操作，(char)(temp+'A'-1)。对于Z我们需要减一，对于A-Y也需要减一，如果我们可以减这两种减一统一起来事情就变得简单了。所以我们可以考虑在取余之前就整体减一。我们可以证明对于26的N倍（num%26 = N），我们整体减一在取余就会得到(num-1)%26 = N-1余25，所以25直接加上A的ASCII码就得Z，所以对于Z而言是可以提前减一的。对于A-Y而言num%26 = N余t，t属于1到25的范围。这个t减一在加上'A'的ASCII码就对于与A-Y（t+'A'-1），而如果我们提前减一的话这个表达式就变成了(num-1)%26 =N余t-1;最后我们的到的值就不用进行减一操作（t-1+'A'）。所以可以将Z和A-Y的操作统一起来了，提前减一，然后再正常取模即可。、

卧槽！！！太简单了吧！！！我吐血了！！！
其实本来也是有想到减1的思路的，但是当时没有好好思考应该在哪里进行减1操作，导致最后代码非常臃肿庞大。。。也有一个原因就是昨晚做题太赶了，看着是简单题就总是想赶出答案，所以做题还是得静下心来啊


