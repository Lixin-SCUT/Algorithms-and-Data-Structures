题目描述：  
> 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。  
示例:  
nums = [1, 2, 3]  
target = 4  
所有可能的组合为：  
(1, 1, 1, 1)  
(1, 1, 2)  
(1, 2, 1)  
(1, 3)   
(2, 1, 1)  
(2, 2)  
(3, 1)  
请注意，顺序不同的序列被视作不同的组合。  
因此输出为 7。  
进阶：  
如果给定的数组中含有负数会怎么样？  
问题会产生什么变化？  
我们需要在题目中添加什么限制来允许负数的出现？  

这道题也好像斐波那契  
就是把每个数存在的情况加起来  
重点就在于顺序不同的序列被当成不同的组合  
它的类似题目是  
[动态规划 322. 零钱兑换[中等]](https://lixin-scut.github.io/post/dong-tai-gui-hua-322-ling-qian-dui-huan-zhong-deng/)  
这里的区别是计算可以凑成目标值所需的最少的数字个数  
[动态规划 518. 零钱兑换 II[中等][未做出]](https://lixin-scut.github.io/post/dong-tai-gui-hua-518-ling-qian-dui-huan-iizhong-deng-wei-zuo-chu/)  
这里的区别是只考虑组合不考虑排列，顺序不同的序列被当成相同的组合  

尴尬，超时了。。。  
有一个问题是有些情况根本达不到的，但是却会导致超级大的数。  
然后必须用unsigned int来定义容器类型  
但是我用long就还是会爆炸。。。以后得找一下原因  

```
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        if(0 == target)
        {   return 1;}
        if(nums.empty())
        {   return 0;}
        
        vector<unsigned int> counts(target + 1, 0);
        counts[0] = 1;
        for(int i = 1; i < target + 1; ++i)
        {
            for(auto num : nums)
            {
                if(num <= i)
                {
                     counts[i] +=  counts[i - num]; 
                    //counts[i] = (counts[i] >= INT_MAX - counts[i - num])? 
                    //    INT_MAX : counts[i] + counts[i - num];
                }
            }
        }
        return counts.back();
    }
};
```

网友题解：  
> 题意分析：  
输入数组的每个元素可以使用多次，这一点和「完全背包」问题有点像；  
顺序不同的序列被视作不同的组合，这一点和所有的「背包问题」都不同，与 518. 零钱兑换 II 问题不同的地方就在这一点。  
思路分析：  
遇到这一类问题，做一件事情有很多种做法，每一种做法有若干个步骤，脑子里能想到的常规思路大概有「回溯搜索」、「动态规划」；  
由于不用得到具体的组合表示，因此考虑使用「动态规划」来解。  
https://pic.leetcode-cn.com/fa278029267fedeb06686b784bd322f16b2abf6b61987dc3b5257630570cd38f-377-1.png   
很容易发现「重复问题」，因此，我们可以使用「动态规划」来做，如果题目问具体的解，那么用「回溯搜索」做（「力扣」第 39 题：组合之和）。  
递归求解：由于有大量「重复子问题」，因此必须使用缓存，以避免相同问题重复求解，这个方法叫「记忆化搜索」，在《算法导论》这本书上也把它归入到「动态规划」的定义中。这种思考问题的方式是「从上到下」的，直接面对问题求解，遇到什么问题，就解决什么问题，同时记住结果；  
「动态规划」告诉了我们另一种思考问题的方式：「从底向上」，可以不直接面对问题求解，从这个问题最小的样子开始，通过逐步递推，至到得到所求的问题的答案。  
虽然这个问题没有明显的「最优子结构」，但这种「从底向上」递推的思路是很深刻的，我们也把它归纳到「动态规划」的解法中。  

> 方法：动态规划  
“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。  
1、状态  
对于“状态”，我们首先思考能不能就用问题当中问的方式定义状态，上面递归树都画出来了。当然就用问题问的方式。  
dp[i] ：对于给定的由正整数组成且不存在重复数字的数组，和为 i 的组合的个数。  
思考输出什么？因为状态就是问题当中问的方式而定义的，因此输出就是最后一个状态 dp[n]。  
2、状态转移方程  
由上面的树形图，可以很容易地写出状态转移方程：  
dp[i] = sum{dp[i - num] for num in nums and if i >= num}  
注意：在 0 这一点，我们定义 dp[0] = 1 的，它表示如果 nums 里有一个数恰好等于 target，它单独成为 1 种可能。  
参考代码：  
```
Java
public class Solution {

    /**
     * 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：
     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 >= 0）
     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案
     * 再举一个具体的例子：nums=[1, 3, 4], target=7;
     * dp[7] = dp[6] + dp[4] + dp[3]
     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];
     *
     * @param nums
     * @param target
     * @return
     */
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        // 这个值被其它状态参考，设置为 1 是合理的
        dp[0] = 1;

        for (int i = 1; i <= target; i++) {
            for (int num : nums) {
                if (num <= i) {
                    dp[i] += dp[i - num];
                }
            }
        }
        return dp[target];
    }
}
```
> 对于进阶问题的思考  
1、如果给定的数组中含有负数会怎么样？问题会产生什么变化？  
如果有负数，相当于给定数组中的元素有了更多的组合，特别是出现了一对相反数的时候，例如题目中的示例 [-4, 1, 2, 3, 4]，target = 4 的时候，-4 和 4 可以无限次地、成对添加到题目中的示例中，成为新的组合，那么这道问题就没有什么意义了。  
仔细思考，负数我只要不选它就行了。但由于这道问题的问法是“组合”，因此我们要保证有负数参与进来，不能够与已有的正数的组合之和为 0 即可。  
2、我们需要在题目中添加什么限制来允许负数的出现？  
如果有负数参与进来，不能够与已有的正数的组合之和为 0 ；  
或者限制负数的使用次数，设计成类似 0-1 背包问题的样子。  

