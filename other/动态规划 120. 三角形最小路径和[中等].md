题目描述：
> 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。     
例如，给定三角形：       
[             
     [2],      
    [3,4],       
   [6,5,7],      
  [4,1,8,3]      
]        
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。       
说明：         
如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。        
来源：力扣（LeetCode）       
链接：https://leetcode-cn.com/problems/triangle      
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。     

第一反应是每层选择最小的数字，但是很明显这样子是不行的
比如 [0]、[10，0]、[0, 99, 99] 明显第二层应该选10而不是0
偷看标签知道是动态规划
面对题目编程的话，普通方法应该是n^2的复杂度
然后突然就来灵感了
用一个容量为n的容器保存每一层每一个格子的路径和
状态转移方程就是上一层两个可能的转移的节点的最小值加上当前节点的和，比如5这个节点就只需要考虑3和4
然后如果不可能的位置就置为0吧
本质上应该用一个容量为n*n的容器，n是层数，我的方法是直接进行了空间压缩

hhh实现的时候有个问题，我一开始从前到后更新，发现这样会被覆盖啊。。。比如0依赖于-1和0，但是1依赖于0和1，0已经被覆盖了

实现中注意的问题
1. 我把数组的长度修改为n+1，这样第一个数就不要单独判断了，但是相应地内循环需要修改判断条件和下标
2. 因为我选择了初始化为INT_MAX，所以必须手动导入第一行，另外导致必须手动判断空数组
3. 从后到前更新，原因前面有说

```
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        if(n == 0)
        {   return 0; }
        vector<int> counts(n + 1, INT_MAX);
        
        counts[1] = triangle[0][0];
        for(int i = 1; i < n; ++i)
        {
            for(int j = i+1; j > 0; --j)
            {
                counts[j] = min(counts[j - 1], counts[j]) + triangle[i][j - 1];
            }
        }
        
        int ans = INT_MAX;
        for(int i : counts)
        {
            ans = min(ans, i);
        }
        return ans;
    }
};
```

然后看了网友题解发现一个很有趣的事，就是外循环可以从底向上，这样子的话确实初始化方便一点。
